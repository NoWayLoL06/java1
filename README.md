# 권용준(202530102)

# ( 10월 30일 강의)

### 객체 지향 상속의 필요성
- 상속이 없는 경우 중복된 멤버를 가짐

- 상속이 있는 경우 중복이 제거되고 간결해짐

### 클래스 상속과 객체
- 선언 : extends 키워드

- 부모 클래스를 물려받아 자식 클래스를 확장의 의미

- 부모 클래스 --> 슈퍼 클래스

- 자식 클래스 --> 서브 클래슷
``` java
class Point {
  int x, y;
}
class ColorPoint extends Point{ // Point를 상속 받음
}
```

### 서브 클래스 객체의 모양
- 슈퍼 클래스 객체와 서브 클래스의 객체는 별개

- 서브 클래스 객체는 슈퍼 클래스 멤버에 포함

### 상속 특징
- 클래스 다중 상속 불허
  - 하나의 클래스 둘 이상의 부모 클래스를 동시에 받는 것

- C++은 다중 상속 가능
- C++은 다중 상속으로 멤버가 중복 생성되는 문제 있음.
  - 부모 클래스 간에 계층적 관계가 있으면, 중복된 멤버가 생설 될 수 있음
  - 모호성의 문제: 두 부모 클래스에 동일한 이름의 멤버가 존재하면 어떤 부모의 멤버를 호출할지 모호해짐

- 자바는 인터페이스의 다중 상속 가능

- 모든 자바 클래스는 묵기적으로 object클래스 상속
  - java.lang.object는 모든 클래스의 슈퍼 클래스

### 슈퍼 클래스의 멥버에 대한 서브 클래스의 접근
- 슈퍼 클래스의 private 멤버: 서브 클래스 접근 불가

- 슈퍼 클래스의 디폴트 멤버: 서브 클래스가 동일 패키지가 있을 때, 가능

- 슈퍼 클래스의 public 멤버: 항상 가능

- 슈퍼 클래싕 protected 멤버: 같은 패키지 내의 모든 클래스 접근 가능

### 서브/슈퍼 클래스의 생성자 호출과 실행
- 서브 클래스의 객체가 생성될 때: 서브/슈퍼 클래스 생성자 모두 실행

- 호출 순서: 서브 --> 슈퍼 클래스 생성자 호출

- 실행 순서: 슈퍼 --> 서브 클래스 생성자 실행

### 서브 클래스와 슈퍼 클래스의 생성자 선택
- 슈퍼/서브 클래스: 여러 개의 생성자 작성 가능

- 서브 클래스의 객체가 생성될 때: 슈퍼 클래스 1개 서브 클래스 1개의 생성자가 실행

- 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식

1. 개발자의 명시적 선택
  - 서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택
  - super() 키워드 사용

2. 컴파일러가 기본 생성자 선택
  - 서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않는 경우
  - 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택

### 컴파일러에 의해 슈퍼 클래스의 기본 생성자가 묵시적 선택(1)
``` java
class A {
  public A() {
    System.out.println("생성자A");
  }
  public A(int x) {
    ....
  }
}
```
``` java
class B extends A {
  public B() {
    System.out.println("생성자B");
  }
}
```
``` java
public class ConstructorEx2 {
  public static void main(Sting[] args) {
    B b;
    b = new B(); // 생성자 호출
  }
}
```

### 서브 클래스의 매개 변수를 가진 생성자에 대해서도 슈퍼 클래스의 기본 생성자가 자동 선택
``` java
class A {
  public A() {
    System.out.println("생성자A");
  }
  public A(int x) {
    System.out.println("매개변수생성자A");
  }
}
```
``` java
class B extends A {
  public B() {
    System.out.println("생성자B");
  }
}
```
``` java
public class ConstructorEx2 {
  public static void main(Sting[] args) {
    B b;
    b = new B(5); // 생성자 호출
  }
}
```

### super()로 슈퍼 클래스의 생성자 명시적 선택
- super(): 서브 클래스에서 명시적으로 슈퍼 클래스 생성자 선택 호출

- 사용 방식
  - super(parameter);
  - 인자를 이용하여 슈퍼 클래스의 적당한 생성자 호출
  - 반드시 서브 클래스 생성자 코드의 제일 첫 라인에 와야 함.

### 업캐스팅(upcasting) 개념
- 하위 클래스의 레퍼런스는 상위 클래스를 가리킬 수 없다 
- 상위 클래스의 레퍼런스는 하위 클래스를 가리킬 수 있다

### 업캐스팅
- 생물이 들어가는 박스에 사람이나 코끼리를 넣어도 무방.
- 사람이나 코끼리 모두 생물이라는 상속 받았기 때문

- 업캐스팅 이란?
  - 서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
  - 슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가리키게 되는 현상

  ```java
  class Person {}
  class Student extends Person {}

  person p;
  Student s = new Student();
  p = s; // 업캐스팅
  ```

### 업캐스팅 사례
```java
class Person{
  String name;
  String id;

  public Person(String name) {
    this.name = name;
  }
}
class Student extends Person {
  String grade;
  String department;

  public Student(String name) {
    super(name);
  }
}
public class UpcastingEx {
  public static void main(String[] args) {
    Person p;
    Student s = new Student("이재문");
    p = s;

    System.out.println(p.name); // 오류 없음

    p.grade = "A"; // 컴파일 오류
    p.department = "Com"; // 컴파일 오류
  }
}
```

### static 메소드의 제약 조건 1
- static 메소드는 오직 static 멤버만 접근 가능
  - 객체가 생성되지 않은 상황에서도 static 메소드는 실행될 수 있기 때문
  - non-static멤버도 사용가능

### static 메소드의 제약 조건 2
- this(레퍼런스) 시용 불가

- 객체 없이도 사용 가능 

### final 클래스와 메소드
- final 클래스 - 더 이상 값 변환 불 가능

### final 필드
- 상수를 선언할 때 사용

# ( 10월 23일 강의)

### 클래스와 객체
- 실 세계 객체의 특징
  - 객체마다 고유헌 특성(state)와 행동(behavior)를 가짐
  - 다른 객체들과 상호작용하면서 살아감

- 컴퓨터 프로그램에서 객체 사례
  - 테트리스 게임의 각 블록들
  - 한글 프로그램의 메뉴나 버튼들

### 객체 지향 특성 : 캡슐화
- 캡슐화: 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
  - 객체의 가장 본질적인 특징
  - 외부의 접근으로부터 객체 보호

- 자바의 캡슐화
  - 클래스(class): 객체 모양을 선언한 틀(캡슐화하는 틀)
  - 객체: 생성된 실체(instance): 클래스 내에 메소드와 필드 구현

### 객체 지향 특성 : 상속
- 상속
  - 상위 객체의 속성이 하위 객체에 물려 줌
  - 하위 객체가 상위 객체의 속성을 모두 가지는 관계

- 실세계의 상속 사례
  - 나무는 식물의 속성과 생물의 속성을 모두 가짐
  - 사람은 생물의 속성을 가지지만 식물의 속성은 가지고 있지 않음

### 자바의 상속
- 자바의 상속
  - 상위 클래스의 멤버를 하위 클래스 물려 받음
  - 상위 클래스: 수퍼 클래스
  - 하위 클래스: 서브 클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 가능

### 객체 지향 특성 : 다형성
- 다형성
  - 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것

- 다형성 사례
  - 메소드 오버로딩: 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
  - 메소드 오버라이딩: 수퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현

### 객체 지향 언어의 목적
1. 소프트웨어의 생산성 향상
- 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(Life cycle) 단축
  - 소프트웨어를 빠른 속도로 생산할 필요성 중대

- 객체 지향 언어
  - 상속, 다향성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
  - 소프트웨어 재사용과 부분 수정 빠름
  - 소프트웨어를 다시 만드는 부담 대폭 줄임
  - 소프트웨어 생산성 향상

2. 실세계에 대한 쉬운 모델링
- 초기 프로그래밍
  - 수학 계산.통계 처리를 하는 등 처리 과정, 계산 절차 중요

- 현대 프로그래밍
  - 컴퓨터가 산업 전반에 활용
  - 실세계에서 발생하는 일을 프로그래밍
  - 실세계에서는 절차나 과정보다 물체(객체)들의 상호 작용으로 묘사하는 것이 용이

- 객체 지향 언어
  - 실세계의 일을 보다 쉽게 프로그래밍하기 위한 객체 중심적 언어

### 절자 지향 프로그래밍과 객체 지향 프로그래밍
- 절차 지향 프로그래밍
  - 작업 순서를 표한하는 컴퓨터 명령 집합
  - 함수들의 집합으로 프로그램 작성

- 객체 지향 프로그래밍
  - 컴퓨터가 수행하는 작업을 객체들 간의 상호 작용으로 표현
  - 클래스 혹은 객체들의 집합으로 프로그램 작성

 ### 클래스와 객체
 - 클래스: 객체의 속성(state)과 행위(behavior) 선언, 객체의 설계도 혹은 틀.

 - 객체: 클래스의 틀로 찍어낸 실체
  - 프로그램 실행 중에 생성되는 실페
  - 메모리 공간을 갖는 구체적인 실체
  - 인스턴스(instance)라고도 부름

- 사례
  - 클래스: 소나타 자동차, 객체: 출고된 실제 소나타 100대

### 자바 클래스 구성
- 클래스
  - class 키워드로 선언
  - 멤버: 클래스 구성 요소. 필드(멤버 변수)와 메소드(멤버 한수)
  - 클래스에 대한 public 접근 지정: 다른 모든 클래스에서 클래스 사용 허락
  - 멤버에 대한 public 접근 지정: 다른 모든 클래스에게 멤버 접근 허용

### 생성자의 특징
- 생성자 이름은 클래스 이름과 동일

- 생성자는 여러 개 작성 가능(생성자 중복)

- 생성자는 객체 생성시 한 번만 호출

- 생성자의 목적은 객체 생성 시 초기화

- 생성자는 리턴 타입을 지정할 수 없음

### 생성자의 종류
- 기본 생성자(default constuctor): 매개 변수 없고, 아무 작업 없이 단순 리턴하는 생성자

- 기본 생성자가 자동 생성되는 경우
  - 클래스에 생성자가 하나도 선언되어 있지 않을 때
  - 컴파일러에 의해 기본 생성자 자동 생성

- 기본 생성자가 자동 생성되지 않은 경우
  - 클래스에 생성자가 선언되어 있는 경우
  - 컴파일러는 기본 생성자를 자동 생성해주지 않는다

### this 레퍼런스
- 객체 자신에 대한 레퍼런스

- 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨

- this.멤버 형태로 멤버를 접근할 떄 사용

### this()로 다른 생성자 호출
- 같은 클래스의 다른 생성자 호출

- 생성자 내에서만 사용 가능

- 생성자 코드의 제일 앞에 있어야 함

- this() 사용 실패 사례
``` java
public Book() {
  System.out.println("생성자 호출됨");
        this("","",0); // 생성자의 첫 번쨰 문장이 아니기에 오류
    }
```

### 객체 배열
- 객체에 대한 레퍼런스 배열

- 자바의 객체 배열 만들기 3단계
  1. 배열 레퍼런스 변수 선언
  2. 레퍼런스 배열 생성
  3. 배열의 각 원소 객체 생성

### 메소드
- 메소드는 C/C++의 함수와 동일

- 자바의 모든 메소드는 반드시 클래스 안에 있어야 함

- 접근 지정자: 다른 클래스에서 메소드를 접근할 수 있는지 여부 선언
  - public, private, protected, 디폴트(접근 지정자 생략)

- 리턴 타입: 메소드가 리턴하는 값의 데이터 타입

### 인자 전달 - 기본 타입의 값이 전달되는 경우
- 매개 변수가 byte, int, double 등 기본 타입으로 선언되었을 때
  - ---> 호출자가 건네는 값이 매개 변수에 복사되어 전달. 실 인자 값은 변경되지 않음

### 인자 전달 - 객체가 전달되는 경우
  - 객체의 레퍼런스만 전달: 매개 변수가 실 인자 객체 공유

### 메소드 오버로딩
- 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
  - 메소드 이름이 동일해야 함
  - 매개 변수의 개수 혹은 타입이 달라야 함
  - 리턴 타입은 오버로딩과 관련 없음

### 오버로딩 실패 사례
- 매개 변수의 개수와 타입이 같기 때문에 오버로딩 실패

### 객체 치환 시 주의할 점
- 객체 지환은 객체 복사가 아니며, 레퍼런스의 복사이다.

### 객체 소멸
- new로 할당 받은 객체와 메모리를 JVM으로 되돌려 주는 행위

- 자바는 객체 소멸 연산자 없음

- 객체 소멸은 JVM의 고유한 역할


- C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함

- C/C++의 프로그램 작성을 어렵게 만드는 요인

- 자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방

### 가비지
- 가리키는 레퍼런스가 하나도 없는 객체

- 더 이상 접근할 수 없어 사용할 수 없게 된 메모리

- 가비지 컬렉션: 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수정. 반환

### 가비지 컬렉션
- JVM이 가비지 자돋 회수
  - 가용 메모리 공간이 일정 이하로 부족해질 떄
  - 가비지를 수거하여 가용 메모리 공간으로 확보

- 가비지 컬렉터에 의해 자동 수행

- 강제 가비지 컬렉션 강제 수행: System 또는 Runtime 객체의gc() 메소드 호출
``` java
System.gc(); // 가비지 컬렉션 작동 요청

```

- 이 코드는 JVM에 강력한 가비지 컬렉션 요청

- 그러나 JVM이 가비지 컬렉션 시점을 전적으로 판단

### 자바의 패키지 개념
- 패키지

- 상호 관련 있는 클래스 파일(.class)을 저장하여 관리하는 디렉터리

- 자바 응용프로그램은 하나 이상의 패키지로 구성

### 접근 지정자
- 자바의 접근 지정자 4가지: private, protected, public, 디폴트

- 접근 지정자의 목적
  - 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
  - 객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
  - -> 접근 지정은 캡슐화에 묶인 보호를 일부 해제할 목적으로 사용

- 접근 지정자에 따른 클래스나 멤버의 공개 범위

### 클래스 접근 지정
- 다른 클래스에서 사용하도록 허용할 지 지정

- public 클래스: 다른 모든 클래스에게 접근 허용

- 디폴트 클래스: 같은 패키지의 클래스에만 접근 허용

### 멤버 접근 지정
- public 멤버: 패키지에 관계 없이 모든 클래스에게 접근 허용

- private 멤버: 동일 클래스 내에만 접근 허용. 상속 받은 서브 클래스에서 접근 불가.

- protected 멤버:
  - 같은 패키지 내의 다른 모든 클래스에게 접근 허용
  - 상속 받은 서브 클래스는 다른 패키지에 있어도 접근 가능

- 디볼트 멤버: 같은 패키지 내의 다른 클래스에게 접근 허용

### static 멤버
- static 멤버 선언
``` java
class StaticSample() {
  int n;                  // non-static 필드
  void g() {...}          // non-static
  
  static int m;           // static 필드
  static void f() {...}   // static 메소드

}
```

- 객체 생성과 non-static 멤버의 생성
  - : non-static 멤버는 객체가 생성될 때, 객체마다 생긴다.

- 객체마다 n, g()의 non-static 멤버들이 생긴다.

### static 멤버 사용
- 클래스 이름으로 접근 가능
``` java
StaticSample.m = 3;
StaticSample.f();     
```

- 객체읭 멤버로 접근 가능

- non-static 멤버는 클래스 이름으로 접근 안됨

# ( 10월 2일 강의 )

### 자바 배열(array)
- 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조로 한 번에 많은 메모리 공간 선언.

- 같은 타입의 데이터들이 순차적으로 저장되는 공간으로 인덱스를 이용하여 원소 데이터에 접근.

- 반복문을 이용하여 처리하기에 적합한 자료 구조

- 배열 인데스: 0부터 시작

### 배열 선언과 생성
- (1) 배열에 대한 레퍼런ㅁ스 변수 `intArray` 선언
  - int int Array [];

- (2) 배열 생성
  - intArray = new int [5];

### 배열 선언 및 생성 디테일
- 배열은 선언과 생성의 두 단계 필요 : 선언과 동시에 생성 가능.

- 배열 선언 : 배열의 이름 선언(배열 레퍼런스 변수 선언)
  - int intArray []; or int[] intArray;
  - int intArray [5]; // 크기 지정하면 오류가 발생

- 배열 생성 : 배열 공간 할당 받는 과정
  - intArray = new int[5]; or int intArray[] = new int[5]; // 선언과 동시에 저장

### 배열 인덱스와 배열 원소 접근
- 배열의 인덱스는 0부터, 크기는 1부터.

- 인덱스 잘못 사용
  - 음수 사용 불가
  - 인덱스 범위를 넘은 경우

- 반드시 배열 생성 후 접근

### 레퍼런스 치환과 배열 공유
- 레퍼런스 치환으로 두 레퍼런스가 하나의 배열 공유
  - int inArray[] = rew int[5];
  - int myArray[] intArray;

### 배열의 크기, length 필드
- 자바의 배열은 객체로 처리
- 배열의 크기는 배열 객체의 length 필드에 저장

### 함수호출 시 배열 전달 비교: C/C++ vs. 자바
- 자바가 C/C++에 비래 배열을 다루기 10배 편한 구조

### 배열과 for-each 문
- `for-each`문 : 배열이나 나열의 원소를 순차 접근하는데 우용한 `for`문

### 2차원 배열
- 2차원 배열 선언
  - int intArray[][]; or int[][]Array;
- 2차원 배열 생성
  - intArray = new int[2][5]; or int intArray[] = new int[2][5]; // 배열 선언과 생성 동시

- 2차원 배열의 length 필드
  - i.length --> 2차원 배열의 행의 개수로, 2
  - i[n].leng --> n번쨰 행의 열의 개수
  - i[1].length --> 1번째 행의 열의 개수, 5

### 2차원 배열의 초기화
  - 배열 선언과 동시에 초기화

### 메소드의 배열 리턴
- 배열의 레퍼런스만 리턴되며, 배열 전체가 리턴되는 것이 아님

- 메소드의 리턴 타입
  - 리턴하는 배열과 티런 받는 배열 타입이 일치
  - 리턴 타입에 배열의 크기르 지정하지 않음.

### 자바의 예외 처리
- 예외 : 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생 --> 자바에서는 실행 중 발생하는 에러를 예외로 처리

- 실행 중 예외가 발생하면 : 자바 츨랫폼은 응용프로그램이 예외를 처리하도록 호출 --> 응용프로그램이 예외를 처리하지 않으면 프로그램 강제 종료 시킴

### 자바의 예외 처리, try-catch-finally문
- 예외 처리 : 발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것

- try-catch-finally문 사용. finally 블록은 생략 가능.

## 반복문
### `continue`문
- 반복문을 빠져 나가지 않고, 계속 다음 반복을 제어

### `break`문
- 반복문 하나를 즉시 벗어날 떄 사용. (하나의 반복문 만)
- 중첩 반복의 경우 안쪽 반복문의 break 문이 실행되면 안쪽 반복문만 벗어남.



# ( 9월 25일 강의 )
### 반복문
- 자바 반복문 - `for`, `while`, `do-while` 문
  - `for` : 반복의 휫수가 정해져 있을 때
  - `while` : 반복의 휫수가 무한일 떄
  - `do-while` : 조건식이 '참'인 동안 반복 실행. 작업문은 한 번 반드시 실행.

### 중첩 반복
- 반복문이 다른 반복문을 내포하는 구조
- 10000명의 학생이 있는 100개 대학의 모든 학생 설적의 합을 구할 떄, `for` 문을 이용하면 좋음

### Switch 문
- `Switch`문의 식과 `case` 문의 값과 비교
  - `case`의 비교 값과 일치하면 해당 `case`의 실행문장 수행
  - `break` 만나는 `switch`문을 벗어남
  - `case`의 비교 값과 일치하는 것이 없으면 `default` 문 실행
  - `default`문은 생략 가능

### While 문
- `While`문의 구성과 코드 사례 : 조건식이 '참'인 동안 반복 실행

``` java
public class Main {
    public static void main(String[] args) {
        switch(식){
          case'A':
          --- 실행 문장 1 ---
        }
    }
}
```

### case 문의 값
- 문자, 정수, 문자열 리터럴만 허용
- 실수 리터럴은 허용되지 않음

### do-while 문
- `do-while` 문의 구성과 코드 사례
  - 조건식이 '참'인 동안 반복 실행. 작업문은 한 번 반드시 실행.

### 다중 if-else 문

- 다중 if문

- 조건문이 너무 많은 경우, `switch` 문 사용 권장

``` java
public class Main {
    public static void main(String[] args) {
        if(조건식 1){
          --- 실행문장 1 ---
        }
        else if(조건식 2){
          --- 실행문장 2 ---
        }
        else if(조건식 m){
          --- 실행문장 m ---
        }
    }
}
```

### 조건문 - 단순 if문, if-else문
- 단순 if 문
  - if의 괄호 안에 조건식(논리형 변수나 논리 연산)
  
  - 실행문장이 단일 문장인 경우 둘어싸는 {, } 생략 가능

``` java
public class Main {
    public static void main(String[] args) {
        if(조건식){
          --- 실행문장 1 ---
        }
    }
}
```

- if-else 문
  - 조건식이 true면 실행문장 1, false면 실행문장 2 실행

``` java
public class Main {
    public static void main(String[] args) {
        if(조건식){
          --- 실행문장 1 ---
        }
        else{
          --- 실행문장 2 ---
        }
    }
}
```

### 비트 연산
- 비트 개념
  - 비트 논리 연산 : 비트끼리 AND, OR, XOR, NOT 연산
  
  - 비트 시프트 연산 : 비트를 오른쪽이나 왼쪽으로 이동

#### 비트 연산이 사용되는 경우
- 비트 연산은 하드웨어 프로그래밍 뿐만 아니라 일반 소프트웨어 개발에서도 여러 가지 용도로 사용.

- 성능이 중요한 경우, 최척화가 필요한 경우

1. 성능 최적화 및 연산 속도 향상 : `*` 과 `/` 보다 비트 연산 `<<`,`>>` 이 훨씬 빠름

2. 권한 및 플래그 설정 : 여러 개의 상태를 하나의 int 변수에 저장할 때 사용

3. 데이터 압축 및 최적화
  - 불필요한 공간 줄이기 위해 여러 개의 작은 값을 하나의 정수에 저장

4. 해상 및 암호화
  - 비트 연산을 활용하여 해시 함수 및 암호화 알고리즘 최적화

5. 빠른 연산

### 조건 연산
- 3개의 피연산자로 구성된 삼항(ternary) 연산자

- ope17opr2:opr3 --> opr1이 결과가, true면 opr2, false면 opr3

- if-else을 조건연산자로 간결하게 표현 가능

### 연산자
- 비교  
  - `>` : 크다 (Greater than) 
  - `<` : 작다 (Less than) 
  - `>=` : 크거나 같다 (Greater or Equal) 
  - `<=` : 작거나 같다 (Less or Equal) 
  - `==` : 같다 (Equal)  
  - `!=` : 같지 않다 (Not Equal) 

- 비트  
  - `&` : 비트 AND 
  - `|` : 비트 OR 
  - `^` : 비트 XOR  
  - `~` : 비트 NOT  

- 논리  
  - `&&` : 논리 AND (그리고)  
  - `||` : 논리 OR (또는)  
  - `!` : 논리 NOT (부정)  
  - `^` : 논리 XOR (배타적 OR)

# ( 9월 18일 강의 )
### 자바의 기본 구조
주석 / 클래스 생성 / main() 메소드 / 메소드 / 메소드 호출 / 변수 선언 / 문장 ; / 출력

### 식별자
- 정의 - 클래스, 변수, 상수, 메소드 등에 붙이는 이름

- 유니코드 사용 가능, 한글 사용 가능 --> 한글 추천 안함

- 자바 언어의 키워드는 식별자로 사용불가.

- 식별자의 첫 번째 문자로 숫자는 사용 불가.

- '_' 또는 '\'를 식별자 첫 번째 문자로 사용할 수 있으나 일반적으로 잘 사용하지 않는다.

- 불린 리터럴 (true, false)과 널 리터럴(null)은 식별자로 사용불가.

- 길이 제한 없음

- 대소문자 구별 : barChart 와 barchart 다른 식별자

### 데이터 타입

- 문자열은 기본 타입 아님. String 클래스로 문자열 표현

- 문자열 리터럴(Literal) : "JDK", "한글", "계속하세요"

- 문자열이나 문자열과 다른 자료형의 리터럴을 + 연산을 할 경우 결과는 문자열로 반환합니다.

### 참조 자료형

- 포인터는 임의의 메모리 주소로 저장, 참조 자료형은 주소 저장할 수 없음

- 직접 주소를 갖고 있지는 않지만, JVM이 해당 주소로 안내해줍니다.

- 참조 자료형은 JVM이 대신 객체의 주소를 저장.

- 배열, 인터페이스, 혹은, 열거형도 참조 자료형.

- 객체를 참조하지 않을 떄 null 값을 가짐.

- 같은 객체를 여러 변수가 참조, == 연산자로 객체의 주소를 비교 가능.

- '래퍼런스'라고 부르면 됨

### 메모리의 구조

- 힙( heap - FIFO ) 영역은 프로그래머가 직접 할당, 해제하는 메모리 공간, JVM이 담당
- 스택 ( stack - LIFO ) 영역은 프로그램이 자동으로 사용하는 임시 메모리
- 힙이 스택을 침범하는 경우 오버 플로우
    - 스택이 힙을 침범하는 경우 스택 오버 플로우 

### 상수 선언
- final 키워드 사용
- 선언할 때 초기값 지정
- 실행 중 값 변경 불가능

### var 키워드
- type 생략하고 변수 선언 가능
- 지역 변수 선언에만 사용 가능, class 필드에서는 사용 불가능
    - 지역 변수 : method 내부에 선언되는 변수
    - class 필드 : class 내부에 선언되는 변수, 객체가 생성될 떄 함께 만들어지는 변수.

### print
- `System.out.print();`
    - 줄 바꿈을 하지 않고 한 줄로 출력
- `System.out.println();`
    - 출력 후 자동으로 줄 바꿈
- `System.out.printf();`
    - 특정한 형식 ( 소수점 자리 수, 정렬 등 )으로 출력할 때 유용

### 타입 변환
- 다른 데이터 타입의 값으로 변환

### 연산자
- 증감  
  - `++` : 변수 값을 1 증가  
  - `--` : 변수 값을 1 감소  

- 산술  
  - `+` : 더하기  
  - `-` : 빼기  
  - `*` : 곱하기  
  - `/` : 나누기  
  - `%` : 나머지  

- 시프트  
  - `>>` : 오른쪽 시프트 (부호 유지)  
  - `<<` : 왼쪽 시프트  
  - `>>>` : 오른쪽 시프트 (부호 무시, 0으로 채움)  

- 비교  
  - `>` : 크다  
  - `<` : 작다  
  - `>=` : 크거나 같다  
  - `<=` : 작거나 같다  
  - `==` : 같다 (값 비교)  
  - `!=` : 같지 않다  

- 비트  
  - `&` : 비트 AND  
  - `|` : 비트 OR  
  - `^` : 비트 XOR  
  - `~` : 비트 NOT  

- 논리  
  - `&&` : 논리 AND (그리고)  
  - `||` : 논리 OR (또는)  
  - `!` : 논리 NOT (부정)  
  - `^` : 논리 XOR (배타적 OR)  

- 조건  
  - `? :` : 조건 연산자 (삼항 연산자)  

- 대입  
  - `=` : 대입  
  - `*=` : 곱 후 대입  
  - `/=` : 나눈 후 대입  
  - `+=` : 더한 후 대입  
  - `-=` : 뺀 후 대입  
  - `&=` : 비트 AND 후 대입  
  - `^=` : 비트 XOR 후 대입  
  - `|=` : 비트 OR 후 대입  
  - `<<=` : 왼쪽 시프트 후 대입  
  - `>>=` : 오른쪽 시프트 후 대입  
  - `>>>=` : 부호 무시 오른쪽 시프트 후 대입
   
# ( 9월 11일 강의 )

# ( 9월 4일 강의 )
# Markdown 문법

## HTML에서 `<h1>` ~ `<h6>`

# 글자 크기 
## 글자 크기
### 글자 크기
#### 글자 크기
##### 글자 크기
###### 글자 크기

# 문자 강조
*이탤릭체*  
**굵은 문자**

수평선
***

# 리스트 
* 언오더드 리스트
* 언오더드 리스트
* 언오더드 리스트
    * 언오더드 리스트
    * 언오더드 리스트
    * 언오더드 리스트
        * 언오더드 리스트
        * 언오더드 리스트
        * 언오더드 리스트

1. 오더드리스트
1. 오더드리스트
1. 오더드리스트


``` java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
```
인라인 코드는 `버튼`이나 코드 조각을 강조할 때 사용

Vs Code에서 터미널을 열려면 `Ctrl` + `~`


# 링크

## 외부 링크
[구글 접속](https://google.com "구글 주소")

## 내부 링크
[링크 라벨](#markdwon-문법 "markdwon-문법")

# 그림 삽입
