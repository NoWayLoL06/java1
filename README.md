# 권용준(202530102)
# ( 10월 2일 강의 )

### 자바 배열(array)
- 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조로 한 번에 많은 메모리 공간 선언.

- 같은 타입의 데이터들이 순차적으로 저장되는 공간으로 인덱스를 이용하여 원소 데이터에 접근.

- 반복문을 이용하여 처리하기에 적합한 자료 구조

- 배열 인데스: 0부터 시작

### 배열 선언과 생성
- (1) 배열에 대한 레퍼런ㅁ스 변수 `intArray` 선언
  - int int Array [];

- (2) 배열 생성
  - intArray = new int [5];

### 배열 선언 및 생성 디테일
- 배열은 선언과 생성의 두 단계 필요 : 선언과 동시에 생성 가능.
- 배열 선언 : 배열의 이름 선언(배열 레퍼런스 변수 선언)
  - int intArray []; or int[] intArray;
  - int intArray [5]; // 크기 지정하면 오류가 발생
- 배열 생성 : 배열 공간 할당 받는 과정
  - intArray = new int[5]; or int intArray[] = new int[5]; // 선언과 동시에 저장

### 배열 인덱스와 배열 원소 접근
- 배열의 인덱스는 0부터, 크기는 1부터.

- 인덱스 잘못 사용
  - 음수 사용 불가
  - 인덱스 범위를 넘은 경우

- 반드시 배열 생성 후 접근

### 레퍼런스 치환과 배열 공유
- 레퍼런스 치환으로 두 레퍼런스가 하나의 배열 공유
  - int inArray[] = rew int[5];
  - int myArray[] intArray;

### 배열의 크기, length 필드
- 자바의 배열은 객체로 처리
- 배열의 크기는 배열 객체의 length 필드에 저장

### 함수호출 시 배열 전달 비교: C/C++ vs. 자바
- 자바가 C/C++에 비래 배열을 다루기 10배 편한 구조

### 배열과 for-each 문
- `for-each`문 : 배열이나 나열의 원소를 순차 접근하는데 우용한 `for`문

### 2차원 배열
- 2차원 배열 선언
  - int intArray[][]; or int[][]Array;
- 2차원 배열 생성
  - intArray = new int[2][5]; or int intArray[] = new int[2][5]; // 배열 선언과 생성 동시

- 2차원 배열의 length 필드
  - i.length --> 2차원 배열의 행의 개수로, 2
  - i[n].leng --> n번쨰 행의 열의 개수
  - i[1].length --> 1번째 행의 열의 개수, 5

### 2차원 배열의 초기화
  - 배열 선언과 동시에 초기화

### 메소드의 배열 리턴
- 배열의 레퍼런스만 리턴되며, 배열 전체가 리턴되는 것이 아님

- 메소드의 리턴 타입
  - 리턴하는 배열과 티런 받는 배열 타입이 일치
  - 리턴 타입에 배열의 크기르 지정하지 않음.

### 자바의 예외 처리
- 예외 : 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생 --> 자바에서는 실행 중 발생하는 에러를 예외로 처리

- 실행 중 예외가 발생하면 : 자바 츨랫폼은 응용프로그램이 예외를 처리하도록 호출 --> 응용프로그램이 예외를 처리하지 않으면 프로그램 강제 종료 시킴

### 자바의 예외 처리, try-catch-finally문
- 예외 처리 : 발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것

- try-catch-finally문 사용. finally 블록은 생략 가능.

## 반복문
### `continue`문
- 반복문을 빠져 나가지 않고, 계속 다음 반복을 제어

### `break`문
- 반복문 하나를 즉시 벗어날 떄 사용. (하나의 반복문 만)
- 중첩 반복의 경우 안쪽 반복문의 break 문이 실행되면 안쪽 반복문만 벗어남.



# ( 9월 25일 강의 )
### 반복문
- 자바 반복문 - `for`, `while`, `do-while` 문
  - `for` : 반복의 휫수가 정해져 있을 때
  - `while` : 반복의 휫수가 무한일 떄
  - `do-while` : 조건식이 '참'인 동안 반복 실행. 작업문은 한 번 반드시 실행.

### 중첩 반복
- 반복문이 다른 반복문을 내포하는 구조
- 10000명의 학생이 있는 100개 대학의 모든 학생 설적의 합을 구할 떄, `for` 문을 이용하면 좋음

### Switch 문
- `Switch`문의 식과 `case` 문의 값과 비교
  - `case`의 비교 값과 일치하면 해당 `case`의 실행문장 수행
  - `break` 만나는 `switch`문을 벗어남
  - `case`의 비교 값과 일치하는 것이 없으면 `default` 문 실행
  - `default`문은 생략 가능

### While 문
- `While`문의 구성과 코드 사례 : 조건식이 '참'인 동안 반복 실행

``` java
public class Main {
    public static void main(String[] args) {
        switch(식){
          case'A':
          --- 실행 문장 1 ---
        }
    }
}
```

### case 문의 값
- 문자, 정수, 문자열 리터럴만 허용
- 실수 리터럴은 허용되지 않음

### do-while 문
- `do-while` 문의 구성과 코드 사례
  - 조건식이 '참'인 동안 반복 실행. 작업문은 한 번 반드시 실행.

### 다중 if-else 문

- 다중 if문

- 조건문이 너무 많은 경우, `switch` 문 사용 권장

``` java
public class Main {
    public static void main(String[] args) {
        if(조건식 1){
          --- 실행문장 1 ---
        }
        else if(조건식 2){
          --- 실행문장 2 ---
        }
        else if(조건식 m){
          --- 실행문장 m ---
        }
    }
}
```

### 조건문 - 단순 if문, if-else문
- 단순 if 문
  - if의 괄호 안에 조건식(논리형 변수나 논리 연산)
  
  - 실행문장이 단일 문장인 경우 둘어싸는 {, } 생략 가능

``` java
public class Main {
    public static void main(String[] args) {
        if(조건식){
          --- 실행문장 1 ---
        }
    }
}
```

- if-else 문
  - 조건식이 true면 실행문장 1, false면 실행문장 2 실행

``` java
public class Main {
    public static void main(String[] args) {
        if(조건식){
          --- 실행문장 1 ---
        }
        else{
          --- 실행문장 2 ---
        }
    }
}
```

### 비트 연산
- 비트 개념
  - 비트 논리 연산 : 비트끼리 AND, OR, XOR, NOT 연산
  
  - 비트 시프트 연산 : 비트를 오른쪽이나 왼쪽으로 이동

#### 비트 연산이 사용되는 경우
- 비트 연산은 하드웨어 프로그래밍 뿐만 아니라 일반 소프트웨어 개발에서도 여러 가지 용도로 사용.

- 성능이 중요한 경우, 최척화가 필요한 경우

1. 성능 최적화 및 연산 속도 향상 : `*` 과 `/` 보다 비트 연산 `<<`,`>>` 이 훨씬 빠름

2. 권한 및 플래그 설정 : 여러 개의 상태를 하나의 int 변수에 저장할 때 사용

3. 데이터 압축 및 최적화
  - 불필요한 공간 줄이기 위해 여러 개의 작은 값을 하나의 정수에 저장

4. 해상 및 암호화
  - 비트 연산을 활용하여 해시 함수 및 암호화 알고리즘 최적화

5. 빠른 연산

### 조건 연산
- 3개의 피연산자로 구성된 삼항(ternary) 연산자

- ope17opr2:opr3 --> opr1이 결과가, true면 opr2, false면 opr3

- if-else을 조건연산자로 간결하게 표현 가능

### 연산자
- 비교  
  - `>` : 크다 (Greater than) 
  - `<` : 작다 (Less than) 
  - `>=` : 크거나 같다 (Greater or Equal) 
  - `<=` : 작거나 같다 (Less or Equal) 
  - `==` : 같다 (Equal)  
  - `!=` : 같지 않다 (Not Equal) 

- 비트  
  - `&` : 비트 AND 
  - `|` : 비트 OR 
  - `^` : 비트 XOR  
  - `~` : 비트 NOT  

- 논리  
  - `&&` : 논리 AND (그리고)  
  - `||` : 논리 OR (또는)  
  - `!` : 논리 NOT (부정)  
  - `^` : 논리 XOR (배타적 OR)

# ( 9월 18일 강의 )
### 자바의 기본 구조
주석 / 클래스 생성 / main() 메소드 / 메소드 / 메소드 호출 / 변수 선언 / 문장 ; / 출력

### 식별자
- 정의 - 클래스, 변수, 상수, 메소드 등에 붙이는 이름

- 유니코드 사용 가능, 한글 사용 가능 --> 한글 추천 안함

- 자바 언어의 키워드는 식별자로 사용불가.

- 식별자의 첫 번째 문자로 숫자는 사용 불가.

- '_' 또는 '\'를 식별자 첫 번째 문자로 사용할 수 있으나 일반적으로 잘 사용하지 않는다.

- 불린 리터럴 (true, false)과 널 리터럴(null)은 식별자로 사용불가.

- 길이 제한 없음

- 대소문자 구별 : barChart 와 barchart 다른 식별자

### 데이터 타입

- 문자열은 기본 타입 아님. String 클래스로 문자열 표현

- 문자열 리터럴(Literal) : "JDK", "한글", "계속하세요"

- 문자열이나 문자열과 다른 자료형의 리터럴을 + 연산을 할 경우 결과는 문자열로 반환합니다.

### 참조 자료형

- 포인터는 임의의 메모리 주소로 저장, 참조 자료형은 주소 저장할 수 없음

- 직접 주소를 갖고 있지는 않지만, JVM이 해당 주소로 안내해줍니다.

- 참조 자료형은 JVM이 대신 객체의 주소를 저장.

- 배열, 인터페이스, 혹은, 열거형도 참조 자료형.

- 객체를 참조하지 않을 떄 null 값을 가짐.

- 같은 객체를 여러 변수가 참조, == 연산자로 객체의 주소를 비교 가능.

- '래퍼런스'라고 부르면 됨

### 메모리의 구조

- 힙( heap - FIFO ) 영역은 프로그래머가 직접 할당, 해제하는 메모리 공간, JVM이 담당
- 스택 ( stack - LIFO ) 영역은 프로그램이 자동으로 사용하는 임시 메모리
- 힙이 스택을 침범하는 경우 오버 플로우
    - 스택이 힙을 침범하는 경우 스택 오버 플로우 

### 상수 선언
- final 키워드 사용
- 선언할 때 초기값 지정
- 실행 중 값 변경 불가능

### var 키워드
- type 생략하고 변수 선언 가능
- 지역 변수 선언에만 사용 가능, class 필드에서는 사용 불가능
    - 지역 변수 : method 내부에 선언되는 변수
    - class 필드 : class 내부에 선언되는 변수, 객체가 생성될 떄 함께 만들어지는 변수.

### print
- `System.out.print();`
    - 줄 바꿈을 하지 않고 한 줄로 출력
- `System.out.println();`
    - 출력 후 자동으로 줄 바꿈
- `System.out.printf();`
    - 특정한 형식 ( 소수점 자리 수, 정렬 등 )으로 출력할 때 유용

### 타입 변환
- 다른 데이터 타입의 값으로 변환

### 연산자
- 증감  
  - `++` : 변수 값을 1 증가  
  - `--` : 변수 값을 1 감소  

- 산술  
  - `+` : 더하기  
  - `-` : 빼기  
  - `*` : 곱하기  
  - `/` : 나누기  
  - `%` : 나머지  

- 시프트  
  - `>>` : 오른쪽 시프트 (부호 유지)  
  - `<<` : 왼쪽 시프트  
  - `>>>` : 오른쪽 시프트 (부호 무시, 0으로 채움)  

- 비교  
  - `>` : 크다  
  - `<` : 작다  
  - `>=` : 크거나 같다  
  - `<=` : 작거나 같다  
  - `==` : 같다 (값 비교)  
  - `!=` : 같지 않다  

- 비트  
  - `&` : 비트 AND  
  - `|` : 비트 OR  
  - `^` : 비트 XOR  
  - `~` : 비트 NOT  

- 논리  
  - `&&` : 논리 AND (그리고)  
  - `||` : 논리 OR (또는)  
  - `!` : 논리 NOT (부정)  
  - `^` : 논리 XOR (배타적 OR)  

- 조건  
  - `? :` : 조건 연산자 (삼항 연산자)  

- 대입  
  - `=` : 대입  
  - `*=` : 곱 후 대입  
  - `/=` : 나눈 후 대입  
  - `+=` : 더한 후 대입  
  - `-=` : 뺀 후 대입  
  - `&=` : 비트 AND 후 대입  
  - `^=` : 비트 XOR 후 대입  
  - `|=` : 비트 OR 후 대입  
  - `<<=` : 왼쪽 시프트 후 대입  
  - `>>=` : 오른쪽 시프트 후 대입  
  - `>>>=` : 부호 무시 오른쪽 시프트 후 대입
   
# ( 9월 11일 강의 )

# ( 9월 4일 강의 )
# Markdown 문법

## HTML에서 `<h1>` ~ `<h6>`

# 글자 크기 
## 글자 크기
### 글자 크기
#### 글자 크기
##### 글자 크기
###### 글자 크기

# 문자 강조
*이탤릭체*  
**굵은 문자**

수평선
***

# 리스트 
* 언오더드 리스트
* 언오더드 리스트
* 언오더드 리스트
    * 언오더드 리스트
    * 언오더드 리스트
    * 언오더드 리스트
        * 언오더드 리스트
        * 언오더드 리스트
        * 언오더드 리스트

1. 오더드리스트
1. 오더드리스트
1. 오더드리스트


``` java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
```
인라인 코드는 `버튼`이나 코드 조각을 강조할 때 사용

Vs Code에서 터미널을 열려면 `Ctrl` + `~`


# 링크

## 외부 링크
[구글 접속](https://google.com "구글 주소")

## 내부 링크
[링크 라벨](#markdwon-문법 "markdwon-문법")

# 그림 삽입
